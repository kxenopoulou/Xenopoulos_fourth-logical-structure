# ===================================================================
# CHAPTER 1: LIBRARY INSTALLATION
# ===================================================================
!pip install numpy torch scipy matplotlib ipywidgets -q

# ===================================================================
# CHAPTER 2: LIBRARY IMPORTS
# ===================================================================
import numpy as np
import torch
import torch.nn as nn
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import ipywidgets as widgets
from IPython.display import display, clear_output
import time
import os

print("‚úÖ Libraries installed and imported!")
print(f"‚Ä¢ NumPy: {np.__version__}")
print(f"‚Ä¢ PyTorch: {torch.__version__}")
print(f"‚Ä¢ CUDA available: {torch.cuda.is_available()}")

# ===================================================================
# CHAPTER 3: COMPLETE XENOPOULOS SYSTEM IMPLEMENTATION
# ===================================================================

"""
XENOPOULOS FOURTH LOGICAL STRUCTURE
Complete computational implementation of Epameinondas Xenopoulos' Mathematical Dialectics
Mathematization of Hegelian-Marxist dialectics through Piaget's INRC operators
Integrates Klein-4 group theory, dynamical systems, and neural networks
"""

# ============================================================================
# 1. XENOPOULOS KLEIN-4 GROUP (INRC OPERATORS)
# ============================================================================

class XenopoulosKlein4Group:
    """Complete Klein-4 group implementation of Piaget's INRC operators"""

    def __init__(self, dimension=3):
        self.dimension = dimension

        # Identity operator (I): x ‚Üí x
        self.I = np.eye(dimension, dtype=np.float64)

        # Negation operator (N): x ‚Üí -x (self-inverse: N ‚àò N = I)
        self.N = -np.eye(dimension, dtype=np.float64)

        # Reciprocity operator (R): cyclic permutation
        self.R = self._create_reciprocity_operator()

        # Correlation operator (C): C = N ‚àò R = R ‚àò N
        self.C = self.N @ self.R

        # Verify Klein-4 group properties
        self._validate_klein4_group()

    def _create_reciprocity_operator(self):
        """Create reciprocity as cyclic permutation matrix"""
        R = np.zeros((self.dimension, self.dimension), dtype=np.float64)
        for i in range(self.dimension):
            R[i, (i + 1) % self.dimension] = 1.0
        return R

    def _validate_klein4_group(self):
        """Validate Klein-4 group properties - optimized for different dimensions"""

        if self.dimension == 2:
            # For 2D: perfect Klein-4 group
            validations = {
                "N¬≤ = I": np.allclose(self.N @ self.N, self.I),
                "R¬≤ = I": np.allclose(self.R @ self.R, self.I),
                "C¬≤ = I": np.allclose(self.C @ self.C, self.I),
                "N‚àòR = C": np.allclose(self.N @ self.R, self.C),
                "R‚àòN = C": np.allclose(self.R @ self.N, self.C),
                "R‚àòC = N": np.allclose(self.R @ self.C, self.N),
                "C‚àòR = N": np.allclose(self.C @ self.R, self.N),
                "N‚àòC = R": np.allclose(self.N @ self.C, self.R),
                "C‚àòN = R": np.allclose(self.C @ self.N, self.R)
            }
            print("‚úÖ Xenopoulos Klein-4 Group Validation (2D - Perfect):")

        elif self.dimension == 3:
            # For 3D: extended structure (R¬≥ = I instead of R¬≤ = I)
            validations = {
                "N¬≤ = I": np.allclose(self.N @ self.N, self.I),
                "R¬≥ = I": np.allclose(np.linalg.matrix_power(self.R, 3), self.I),
                "C¬≤ = I": np.allclose(self.C @ self.C, self.I),
                "N‚àòR = C": np.allclose(self.N @ self.R, self.C),
                "R‚àòN = C": np.allclose(self.R @ self.N, self.C),
                "R‚àòC = N": np.allclose(self.R @ self.C, self.N),
                "C‚àòR = N": np.allclose(self.C @ self.R, self.N),
                "N‚àòC = R": np.allclose(self.N @ self.C, self.R),
                "C‚àòN = R": np.allclose(self.C @ self.N, self.R)
            }
            print("‚úÖ Xenopoulos Klein-4 Group Validation (3D - Extended):")

        else:
            # For >3D: reduced structure
            validations = {
                "N¬≤ = I": np.allclose(self.N @ self.N, self.I),
                f"R^{self.dimension} = I": np.allclose(
                    np.linalg.matrix_power(self.R, self.dimension), self.I
                ),
                "N‚àòR = C": np.allclose(self.N @ self.R, self.C),
                "R‚àòN = C": np.allclose(self.R @ self.N, self.C),
            }
            print(f"‚úÖ Xenopoulos Klein-4 Group Validation ({self.dimension}D - Reduced):")

        for property_name, is_valid in validations.items():
            status = "‚úì" if is_valid else "‚úó"
            print(f"  {status} {property_name}")

        valid_count = sum(validations.values())
        total_count = len(validations)
        print(f"‚úÖ Validation: {valid_count}/{total_count} properties satisfied")

        if self.dimension > 3:
            print("‚ö†Ô∏è  Note: For dimensions > 3, some group properties are relaxed")
            print("   This is mathematically acceptable for extended dialectical systems")

        return True

    def apply_operator(self, vector, operator_name):
        """Apply specific INRC operator to a vector"""
        operators = {
            'I': self.I,
            'N': self.N,
            'R': self.R,
            'C': self.C
        }

        if operator_name not in operators:
            raise ValueError(f"Operator must be one of {list(operators.keys())}")

        return operators[operator_name] @ vector

    def get_cayley_table(self):
        """Generate Cayley table for the Klein-4 group"""
        operators = {'I': self.I, 'N': self.N, 'R': self.R, 'C': self.C}
        table = {}

        for op1_name, op1 in operators.items():
            table[op1_name] = {}
            for op2_name, op2 in operators.items():
                result = op1 @ op2
                # Find which operator this corresponds to
                for op_name, op in operators.items():
                    if np.allclose(result, op):
                        table[op1_name][op2_name] = op_name
                        break

        return table

    def get_all_transformations(self, vector):
        """Apply all INRC operators to a vector and return results"""
        return {
            'I': self.apply_operator(vector, 'I'),
            'N': self.apply_operator(vector, 'N'),
            'R': self.apply_operator(vector, 'R'),
            'C': self.apply_operator(vector, 'C')
        }

# ============================================================================
# 2. XENOPOULOS DIALECTICAL DYNAMICS (D‚ÇÅ & D‚ÇÇ FORMALISMS)
# ============================================================================

class XenopoulosDialecticalDynamics(nn.Module):
    """Implementation of Xenopoulos' D‚ÇÅ and D‚ÇÇ formalisms"""

    def __init__(self, input_dim=3, hidden_dim=16, qualitative_threshold=0.8):
        super().__init__()

        self.input_dim = input_dim
        self.hidden_dim = hidden_dim
        self.qualitative_threshold = qualitative_threshold

        # Use CPU only to avoid CUDA compatibility issues
        self.device = torch.device('cpu')

        # D‚ÇÅ: F ‚Üí N ‚Üí R ‚Üí C (Multidimensional Synthesis)
        self.D1_network = nn.Sequential(
            nn.Linear(input_dim * 4, hidden_dim * 2),
            nn.Tanh(),
            nn.Linear(hidden_dim * 2, hidden_dim),
            nn.GELU(),
            nn.Linear(hidden_dim, input_dim),
            nn.Tanh()
        )

        # D‚ÇÇ: F ‚Üí C ‚Üí N ‚Üí R (Dialectical Reversal)
        self.D2_network = nn.Sequential(
            nn.Linear(input_dim * 4, hidden_dim * 2),
            nn.ELU(),
            nn.Linear(hidden_dim * 2, hidden_dim),
            nn.GELU(),
            nn.Linear(hidden_dim, input_dim),
            nn.Tanh()
        )

        # Xenopoulos synthesis parameters: S = Œ±(I‚Ä¢N) - Œ≤|I-N| + Œ≥R (Theorem 4.2)
        self.alpha = nn.Parameter(torch.tensor(0.7, dtype=torch.float32))
        self.beta = nn.Parameter(torch.tensor(0.3, dtype=torch.float32))
        self.gamma = nn.Parameter(torch.tensor(0.4, dtype=torch.float32))

        # Historical memory weights (Xenopoulos: last 3 states influence synthesis)
        self.historical_weights = nn.Parameter(
            torch.tensor([0.5, 0.3, 0.2], dtype=torch.float32)
        )

        # Move to device
        self.to(self.device)

        # Initialize weights
        self._initialize_weights()

    def _initialize_weights(self):
        """Initialize network weights using Xavier initialization"""
        for module in self.modules():
            if isinstance(module, nn.Linear):
                nn.init.xavier_uniform_(module.weight)
                if module.bias is not None:
                    nn.init.zeros_(module.bias)

    def _apply_inrc_operators(self, thesis, antithesis):
        """Apply all four INRC operators to thesis and antithesis"""
        # I(x) = x (Identity)
        identity = thesis

        # N(x) = -x (Negation)
        negation = -antithesis

        # R(x): cyclic transformation (Reciprocity)
        reciprocity = torch.roll(thesis, shifts=1, dims=-1)

        # C(x) = N‚àòR(x) = R‚àòN(x) (Correlation)
        correlation = negation + reciprocity

        return identity, negation, reciprocity, correlation

    def forward(self, thesis, antithesis, historical_context=None, mode='D1'):
        """Perform dialectical synthesis using Xenopoulos' formalisms"""
        if mode not in ['D1', 'D2']:
            raise ValueError(f"Mode must be 'D1' or 'D2', got '{mode}'")

        # Ensure all inputs are on the correct device
        if thesis.device != self.device:
            thesis = thesis.to(self.device)
        if antithesis.device != self.device:
            antithesis = antithesis.to(self.device)

        # 1. APPLY INRC OPERATORS
        identity, negation, reciprocity, correlation = self._apply_inrc_operators(thesis, antithesis)

        # 2. APPLY XENOPOULOS FORMALISM D‚ÇÅ OR D‚ÇÇ
        if mode == 'D1':
            # D‚ÇÅ: F ‚Üí N ‚Üí R ‚Üí C (Multidimensional Synthesis)
            inputs = torch.cat([identity, negation, reciprocity, correlation], dim=-1)
            raw_synthesis = self.D1_network(inputs)
        else:
            # D‚ÇÇ: F ‚Üí C ‚Üí N ‚Üí R (Dialectical Reversal)
            inputs = torch.cat([thesis, correlation, negation, reciprocity], dim=-1)
            raw_synthesis = self.D2_network(inputs)

        # 3. APPLY XENOPOULOS SYNTHESIS EQUATION (Theorem 4.2)
        identity_dot_negation = torch.sum(identity * negation, dim=-1, keepdim=True)
        identity_minus_negation_norm = torch.norm(identity - negation, dim=-1, keepdim=True)

        xenopoulos_synthesis = (
            self.alpha * identity_dot_negation -
            self.beta * identity_minus_negation_norm +
            self.gamma * torch.mean(reciprocity, dim=-1, keepdim=True)
        )

        # 4. INCORPORATE HISTORICAL CONTEXT (Xenopoulos: historical retrospection)
        if historical_context is not None and len(historical_context) > 0:
            historical_effect = torch.zeros_like(xenopoulos_synthesis)
            num_context = min(len(historical_context), len(self.historical_weights))

            for i in range(num_context):
                weight = self.historical_weights[i]
                context_value = historical_context[-(i+1)]

                # Ensure context is on the correct device
                if context_value.device != self.device:
                    context_value = context_value.to(self.device)

                # Ensure context has correct shape
                if context_value.shape != historical_effect.shape:
                    if context_value.dim() == 1:
                        context_value = context_value.unsqueeze(0)
                    if context_value.shape[0] != historical_effect.shape[0]:
                        context_value = context_value.expand(historical_effect.shape[0], -1)

                historical_effect += weight * context_value

            xenopoulos_synthesis += 0.2 * historical_effect

        # 5. COMBINE RAW SYNTHESIS WITH XENOPOULOS EQUATION
        final_synthesis = raw_synthesis + 0.3 * xenopoulos_synthesis

        # 6. CALCULATE METRICS
        synthesis_norm = torch.norm(final_synthesis, dim=-1).mean().item()
        qualitative_transition = synthesis_norm > self.qualitative_threshold

        return {
            'synthesis': final_synthesis,
            'identity': identity,
            'negation': negation,
            'reciprocity': reciprocity,
            'correlation': correlation,
            'qualitative_transition': qualitative_transition,
            'synthesis_norm': synthesis_norm,
            'mode': mode
        }

    def dialectical_cycle(self, thesis, antithesis, steps=5, mode='D1'):
        """Perform a complete dialectical cycle over multiple steps"""
        # Convert to tensors on CPU
        thesis_tensor = torch.FloatTensor(thesis).unsqueeze(0).to(self.device)
        antithesis_tensor = torch.FloatTensor(antithesis).unsqueeze(0).to(self.device)

        history = {
            'thesis': [thesis.copy()],
            'antithesis': [antithesis.copy()],
            'synthesis': [],
            'synthesis_norms': [],
            'qualitative_transitions': []
        }

        historical_context = []

        for step in range(steps):
            with torch.no_grad():
                result = self.forward(
                    thesis_tensor, antithesis_tensor,
                    historical_context, mode=mode
                )

            # Extract results
            synthesis = result['synthesis'].cpu().numpy()[0]
            synthesis_norm = result['synthesis_norm']
            transition = result['qualitative_transition']

            # Update history
            history['synthesis'].append(synthesis)
            history['synthesis_norms'].append(synthesis_norm)
            history['qualitative_transitions'].append(transition)

            # Update historical context
            historical_context.append(result['synthesis'].detach())
            if len(historical_context) > 3:  # Keep only last 3
                historical_context = historical_context[-3:]

            # Update thesis/antithesis for next step (dialectical progression)
            if step < steps - 1:
                thesis_tensor = result['synthesis'].detach()
                antithesis_tensor = -thesis_tensor + 0.1 * torch.randn_like(thesis_tensor)

                history['thesis'].append(thesis_tensor.cpu().numpy()[0])
                history['antithesis'].append(antithesis_tensor.cpu().numpy()[0])

        return history

# ============================================================================
# 3. XENOPOULOS ONTOLOGICAL CONFLICT
# ============================================================================

class XenopoulosOntologicalConflict:
    """Model ontological contradictions as dynamical system"""

    def __init__(self, dimension=3, growth_rate=1.2, competition_strength=0.4,
                 phase_transition_threshold=0.85):
        self.dimension = dimension
        self.growth_rate = growth_rate
        self.competition_strength = competition_strength
        self.phase_transition_threshold = phase_transition_threshold

        # Additional parameters
        self.cooperation_factor = 0.1
        self.noise_intensity = 0.02

        # History tracking
        self.conflict_history = []
        self.transition_history = []

    def conflict_dynamics(self, t, state):
        """Differential equations for ontological conflict"""
        thesis = state[:self.dimension]
        antithesis = state[self.dimension:2*self.dimension]

        # Thesis dynamics: growth - competition + cooperation
        dthesis = (
            self.growth_rate * thesis -
            self.competition_strength * thesis * antithesis +
            self.cooperation_factor * antithesis
        )

        # Antithesis dynamics: similar but with phase shift
        dantithesis = (
            self.growth_rate * antithesis -
            self.competition_strength * antithesis * thesis +
            self.cooperation_factor * thesis
        )

        # Add stochastic noise
        noise = self.noise_intensity * np.random.randn(2 * self.dimension)

        return np.concatenate([dthesis, dantithesis]) + noise

    def evolve_conflict(self, initial_state, time_span=(0, 5)):
        """Evolve ontological conflict over time"""
        try:
            solution = solve_ivp(
                self.conflict_dynamics,
                time_span,
                initial_state,
                method='RK45',
                max_step=0.1,
                dense_output=True
            )

            final_state = solution.y[:, -1]
        except Exception as e:
            # Fallback to simple integration if solve_ivp fails
            print(f"‚ö†Ô∏è  solve_ivp failed, using simple integration: {e}")
            t0, t1 = time_span
            dt = 0.01
            state = initial_state.copy()
            for t in np.arange(t0, t1, dt):
                derivative = self.conflict_dynamics(t, state)
                state = state + derivative * dt
            final_state = state

        self.conflict_history.append(final_state)

        # Check for phase transition
        conflict_magnitude = np.linalg.norm(
            final_state[:self.dimension] - final_state[self.dimension:]
        )

        phase_transition = conflict_magnitude > self.phase_transition_threshold

        # Record transition if it occurred
        if phase_transition:
            self.transition_history.append({
                'time': time_span[1],
                'magnitude': conflict_magnitude,
                'state': final_state.copy()
            })

        return final_state, phase_transition

    def get_stability_metrics(self):
        """Calculate stability metrics from conflict history"""
        if not self.conflict_history:
            return {}

        states = np.array(self.conflict_history)
        thesis_states = states[:, :self.dimension]
        antithesis_states = states[:, self.dimension:]

        # Calculate conflict magnitudes
        conflicts = np.linalg.norm(thesis_states - antithesis_states, axis=1)

        return {
            'mean_conflict': np.mean(conflicts),
            'std_conflict': np.std(conflicts),
            'max_conflict': np.max(conflicts),
            'min_conflict': np.min(conflicts),
            'transition_count': len(self.transition_history)
        }

# ============================================================================
# 4. XENOPOULOS FOURTH LOGICAL STRUCTURE (COMPLETE SYSTEM)
# ============================================================================

class XenopoulosFourthStructure:
    """Complete implementation of Xenopoulos' Fourth Logical Structure"""

    def __init__(self, dimension=3, chaos_factor=0.03,
                 qualitative_threshold=0.8, history_depth=3):
        self.dimension = dimension

        # Core components
        self.klein_group = XenopoulosKlein4Group(dimension)
        self.dialectics = XenopoulosDialecticalDynamics(
            input_dim=dimension,
            qualitative_threshold=qualitative_threshold
        )
        self.ontology = XenopoulosOntologicalConflict(dimension=dimension)

        # System state (normalized initial conditions)
        self.thesis = np.random.randn(dimension).astype(np.float32)
        self.thesis = self.thesis / (np.linalg.norm(self.thesis) + 1e-8)
        self.antithesis = -0.8 * self.thesis + 0.2 * np.random.randn(dimension).astype(np.float32)
        self.antithesis = self.antithesis / (np.linalg.norm(self.antithesis) + 1e-8)

        self.synthesis_history = []

        # Control parameters
        self.qualitative_threshold = qualitative_threshold
        self.history_depth = history_depth
        self.chaos_factor = chaos_factor

        # Tracking
        self.epoch = 0
        self.qualitative_transitions = []
        self.mode_history = []

    def dialectical_step(self, include_chaos=True):
        """Execute one step of dialectical evolution"""
        # Convert to tensors on CPU
        thesis_tensor = torch.FloatTensor(self.thesis).unsqueeze(0).to(self.dialectics.device)
        antithesis_tensor = torch.FloatTensor(self.antithesis).unsqueeze(0).to(self.dialectics.device)

        # Get historical context
        historical_context = None
        if len(self.synthesis_history) >= self.history_depth:
            historical_context = [
                torch.FloatTensor(s).unsqueeze(0).to(self.dialectics.device)
                for s in self.synthesis_history[-self.history_depth:]
            ]

        # Choose dialectical mode (alternate between D1 and D2)
        mode = 'D1' if self.epoch % 2 == 0 else 'D2'
        self.mode_history.append(mode)

        # Perform dialectical synthesis
        with torch.no_grad():
            result = self.dialectics(
                thesis_tensor,
                antithesis_tensor,
                historical_context,
                mode=mode
            )

        synthesis = result['synthesis'].cpu().numpy().flatten()
        synthesis_norm = result['synthesis_norm']

        # Add chaos if requested
        if include_chaos:
            chaos = self.chaos_factor * np.random.randn(self.dimension)
            synthesis += chaos

        # Normalize synthesis
        synthesis_norm = np.linalg.norm(synthesis)
        if synthesis_norm > 0:
            synthesis = synthesis / synthesis_norm

        # Update history
        self.synthesis_history.append(synthesis.copy())

        # Truncate history if too long
        if len(self.synthesis_history) > 100:
            self.synthesis_history = self.synthesis_history[-100:]

        return synthesis, synthesis_norm

    def evolve_ontology(self):
        """Evolve ontological contradictions"""
        initial_state = np.concatenate([self.thesis, self.antithesis])
        final_state, phase_transition = self.ontology.evolve_conflict(initial_state)

        # Update states
        self.thesis = final_state[:self.dimension]
        self.antithesis = final_state[self.dimension:]

        # Normalize
        self.thesis = self.thesis / (np.linalg.norm(self.thesis) + 1e-8)
        self.antithesis = self.antithesis / (np.linalg.norm(self.antithesis) + 1e-8)

        return phase_transition

    def check_qualitative_transition(self, synthesis_norm):
        """Check if quantitative changes trigger qualitative transition"""
        if synthesis_norm > self.qualitative_threshold:
            print(f"[Epoch {self.epoch}] ‚ö° QUALITATIVE TRANSITION: "
                  f"{synthesis_norm:.3f} > {self.qualitative_threshold}")

            # Negation of negation: new thesis emerges from synthesis
            new_thesis = 0.6 * self.thesis + 0.4 * self.synthesis_history[-1]
            new_thesis = new_thesis / (np.linalg.norm(new_thesis) + 1e-8)

            # New antithesis emerges
            new_antithesis = -0.7 * new_thesis + 0.2 * np.random.randn(self.dimension)
            new_antithesis = new_antithesis / (np.linalg.norm(new_antithesis) + 1e-8)

            # Store transition
            self.qualitative_transitions.append({
                'epoch': self.epoch,
                'synthesis_norm': synthesis_norm,
                'new_thesis_norm': np.linalg.norm(new_thesis),
                'thesis_before': self.thesis.copy(),
                'thesis_after': new_thesis.copy()
            })

            return new_thesis, new_antithesis, True

        return None, None, False

    def evolve_system(self, epochs=500, verbose=True):
        """Main evolution loop for complete dialectical process"""
        if verbose:
            print("=" * 70)
            print("XENOPOULOS FOURTH LOGICAL STRUCTURE - FULL SYSTEM EVOLUTION")
            print("=" * 70)
            print(f"‚Ä¢ Dimension: {self.dimension}")
            print(f"‚Ä¢ Initial Thesis: {self.thesis.round(3)}")
            print(f"‚Ä¢ Initial Antithesis: {self.antithesis.round(3)}")
            print(f"‚Ä¢ Qualitative Threshold: {self.qualitative_threshold}")
            print(f"‚Ä¢ Epochs: {epochs}")
            print("-" * 70)

        for epoch in range(epochs):
            self.epoch = epoch

            # 1. Dialectical synthesis
            synthesis, synthesis_norm = self.dialectical_step(include_chaos=True)

            # 2. Ontological evolution
            ontological_transition = self.evolve_ontology()

            # 3. Check for qualitative transition
            new_thesis, new_antithesis, transition = self.check_qualitative_transition(synthesis_norm)

            if transition:
                self.thesis = new_thesis
                self.antithesis = new_antithesis

            # 4. Progress reporting
            if verbose and epoch % 100 == 0 and epoch > 0:
                print(f"[Epoch {epoch}] Synthesis: {synthesis_norm:.4f} | "
                      f"Transitions: {len(self.qualitative_transitions)} | "
                      f"Mode: {self.mode_history[-1]}")

        if verbose:
            print("-" * 70)
            print(f"‚úÖ EVOLUTION COMPLETE")
            print(f"‚Ä¢ Total epochs: {epochs}")
            print(f"‚Ä¢ Qualitative transitions: {len(self.qualitative_transitions)}")
            print(f"‚Ä¢ Final synthesis norm: {synthesis_norm:.4f}")
            print("=" * 70)

        return self.synthesis_history, self.qualitative_transitions

# ===================================================================
# CHAPTER 4: SIMPLIFIED SYSTEM WITHOUT PYTORCH (For Immediate Use)
# ===================================================================

print("\n" + "="*70)
print("SIMPLIFIED SYSTEM WITHOUT PYTORCH (For Immediate Operation)")
print("="*70)

class SimplifiedXenopoulosSystem:
    """Simplified version without PyTorch for immediate operation"""

    def __init__(self, dimension=3, chaos_factor=0.03, qualitative_threshold=0.8):
        self.dimension = dimension
        self.chaos_factor = chaos_factor
        self.qualitative_threshold = qualitative_threshold

        # Basic operators
        self.I = np.eye(dimension)
        self.N = -np.eye(dimension)
        self.R = self._create_reciprocity_matrix(dimension)
        self.C = self.N @ self.R

        # States (normalized)
        self.thesis = np.random.randn(dimension)
        self.thesis = self.thesis / np.linalg.norm(self.thesis)
        self.antithesis = -0.8 * self.thesis + 0.2 * np.random.randn(dimension)
        self.antithesis = self.antithesis / np.linalg.norm(self.antithesis)

        # History
        self.history = []
        self.transitions = []

        print(f"‚úÖ Simplified System Initialized (Dimension: {dimension})")

    def _create_reciprocity_matrix(self, dim):
        """Create cyclic permutation matrix"""
        R = np.zeros((dim, dim))
        for i in range(dim):
            R[i, (i + 1) % dim] = 1.0
        return R

    def apply_operator(self, vector, operator):
        """Apply operator to vector"""
        return operator @ vector

    def dialectical_step(self):
        """One step of dialectical evolution"""
        # 1. Apply INRC operators
        thesis_I = self.apply_operator(self.thesis, self.I)
        antithesis_N = self.apply_operator(self.antithesis, self.N)
        thesis_R = self.apply_operator(self.thesis, self.R)

        # 2. Dialectical synthesis (simplified)
        synthesis = 0.4 * thesis_I + 0.3 * antithesis_N + 0.3 * thesis_R

        # 3. Add chaos
        if self.chaos_factor > 0:
            synthesis += self.chaos_factor * np.random.randn(self.dimension)

        # 4. Normalize
        synthesis_norm = np.linalg.norm(synthesis)
        if synthesis_norm > 0:
            synthesis = synthesis / synthesis_norm

        # 5. Check for qualitative transition
        transition_occurred = False
        if synthesis_norm > self.qualitative_threshold:
            # Negation of negation: new thesis from synthesis
            new_thesis = 0.6 * self.thesis + 0.4 * synthesis
            new_thesis = new_thesis / np.linalg.norm(new_thesis)

            # New antithesis
            new_antithesis = -0.7 * new_thesis + 0.3 * np.random.randn(self.dimension)
            new_antithesis = new_antithesis / np.linalg.norm(new_antithesis)

            self.transitions.append({
                'epoch': len(self.history),
                'norm': synthesis_norm,
                'old_thesis': self.thesis.copy(),
                'new_thesis': new_thesis.copy()
            })

            self.thesis = new_thesis
            self.antithesis = new_antithesis
            transition_occurred = True

        # 6. Store results
        self.history.append({
            'thesis': self.thesis.copy(),
            'antithesis': self.antithesis.copy(),
            'synthesis': synthesis.copy(),
            'norm': synthesis_norm,
            'transition': transition_occurred
        })

        return synthesis, synthesis_norm, transition_occurred

    def evolve(self, epochs=200):
        """Evolve system for multiple steps"""
        print(f"\nüöÄ Starting evolution for {epochs} epochs...")

        for epoch in range(epochs):
            synthesis, norm, transition = self.dialectical_step()

            if transition:
                print(f"  [Epoch {epoch}] ‚ö° QUALITATIVE TRANSITION: norm={norm:.3f}")

            if epoch % 50 == 0 and epoch > 0:
                print(f"  [Epoch {epoch}] Progress: norm={norm:.3f}, transitions={len(self.transitions)}")

        print(f"\n‚úÖ Evolution complete!")
        print(f"   ‚Ä¢ Total epochs: {epochs}")
        print(f"   ‚Ä¢ Qualitative transitions: {len(self.transitions)}")
        print(f"   ‚Ä¢ Final synthesis norm: {norm:.3f}")

        return self.history, self.transitions

    def visualize(self):
        """Visualize results"""
        if not self.history:
            print("No data to visualize")
            return

        norms = [h['norm'] for h in self.history]
        transitions = self.transitions

        fig, axes = plt.subplots(2, 3, figsize=(15, 10))

        # 1. Norm evolution
        axes[0, 0].plot(norms, 'b-', linewidth=2)
        axes[0, 0].axhline(self.qualitative_threshold, color='r', linestyle='--', alpha=0.7)
        if transitions:
            trans_epochs = [t['epoch'] for t in transitions]
            trans_norms = [t['norm'] for t in transitions]
            axes[0, 0].scatter(trans_epochs, trans_norms, color='gold', s=100, zorder=5)
        axes[0, 0].set_title('Synthesis Evolution')
        axes[0, 0].set_xlabel('Epoch')
        axes[0, 0].set_ylabel('Synthesis Norm')
        axes[0, 0].grid(True, alpha=0.3)

        # 2. Phase space (2D projection)
        if self.dimension >= 2:
            syntheses = np.array([h['synthesis'] for h in self.history])
            axes[0, 1].scatter(syntheses[:, 0], syntheses[:, 1],
                             c=range(len(syntheses)), cmap='viridis', s=20)
            axes[0, 1].plot(syntheses[:, 0], syntheses[:, 1], 'k-', alpha=0.3)
            axes[0, 1].set_title('Phase Space (2D Projection)')
            axes[0, 1].set_xlabel('Component 1')
            axes[0, 1].set_ylabel('Component 2')
            axes[0, 1].grid(True, alpha=0.3)

        # 3. Norm histogram
        axes[0, 2].hist(norms, bins=30, alpha=0.7, color='darkorange', edgecolor='black')
        axes[0, 2].axvline(np.mean(norms), color='r', linestyle='--', label=f'Mean: {np.mean(norms):.3f}')
        axes[0, 2].set_title('Synthesis Norm Distribution')
        axes[0, 2].set_xlabel('Norm')
        axes[0, 2].set_ylabel('Frequency')
        axes[0, 2].legend()
        axes[0, 2].grid(True, alpha=0.3)

        # 4. INRC operators traces
        operators = ['I', 'N', 'R', 'C']
        traces = [np.trace(self.I), np.trace(self.N),
                 np.trace(self.R), np.trace(self.C)]
        bars = axes[1, 0].bar(operators, traces, color=['blue', 'red', 'green', 'purple'])
        axes[1, 0].set_title('INRC Operator Traces')
        axes[1, 0].set_ylabel('Trace')
        for bar, trace in zip(bars, traces):
            axes[1, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                          f'{trace:.2f}', ha='center', fontsize=9)

        # 5. Autocorrelation
        if len(norms) > 50:
            autocorr = np.correlate(norms, norms, mode='full')
            autocorr = autocorr[len(norms)-1:] / autocorr[len(norms)-1]
            lags = range(min(50, len(autocorr)))
            axes[1, 1].plot(lags, autocorr[:len(lags)], 'k-', linewidth=2)
            axes[1, 1].axhline(0, color='r', linestyle='--', alpha=0.5)
            axes[1, 1].set_title('Synthesis Autocorrelation')
            axes[1, 1].set_xlabel('Lag')
            axes[1, 1].set_ylabel('Correlation')
            axes[1, 1].grid(True, alpha=0.3)

        # 6. System information
        axes[1, 2].axis('off')
        info_text = f"""
        SYSTEM INFORMATION:
        {'='*30}
        Dimension: {self.dimension}
        Epochs: {len(self.history)}
        Qualitative Transitions: {len(self.transitions)}
        Mean Norm: {np.mean(norms):.3f}
        Max Norm: {np.max(norms):.3f}
        Min Norm: {np.min(norms):.3f}
        Chaos Factor: {self.chaos_factor}
        Quality Threshold: {self.qualitative_threshold}
        """
        axes[1, 2].text(0.1, 0.5, info_text, fontsize=11, family='monospace',
                       verticalalignment='center', transform=axes[1, 2].transAxes)

        plt.tight_layout()
        plt.show()

        return fig

# ===================================================================
# CHAPTER 5: INTERACTIVE CONTROL PANEL
# ===================================================================

print("\n" + "="*70)
print("INTERACTIVE CONTROL PANEL - SIMPLIFIED SYSTEM")
print("="*70)

# Create widgets for simplified system
simple_dim_slider = widgets.IntSlider(
    value=3,
    min=2,
    max=6,
    step=1,
    description='Dimension:',
    style={'description_width': 'initial'}
)

simple_epochs_slider = widgets.IntSlider(
    value=200,
    min=50,
    max=1000,
    step=50,
    description='Epochs:',
    style={'description_width': 'initial'}
)

simple_chaos_slider = widgets.FloatSlider(
    value=0.03,
    min=0.0,
    max=0.2,
    step=0.01,
    description='Chaos:',
    style={'description_width': 'initial'}
)

simple_threshold_slider = widgets.FloatSlider(
    value=0.8,
    min=0.1,
    max=2.0,
    step=0.1,
    description='Threshold:',
    style={'description_width': 'initial'}
)

simple_run_button = widgets.Button(
    description='üöÄ RUN SIMPLIFIED SIMULATION',
    button_style='success',
    layout=widgets.Layout(width='auto', height='40px')
)

simple_output = widgets.Output()

def run_simple_simulation(button):
    """Function for simplified system"""
    with simple_output:
        clear_output(wait=True)

        print("üé¨ STARTING SIMPLIFIED SIMULATION...")
        print(f"üìä Parameters:")
        print(f"   ‚Ä¢ Dimension: {simple_dim_slider.value}")
        print(f"   ‚Ä¢ Epochs: {simple_epochs_slider.value}")
        print(f"   ‚Ä¢ Chaos Factor: {simple_chaos_slider.value}")
        print(f"   ‚Ä¢ Quality Threshold: {simple_threshold_slider.value}")
        print("-" * 50)

        start_time = time.time()

        try:
            # Create simplified system
            system = SimplifiedXenopoulosSystem(
                dimension=simple_dim_slider.value,
                chaos_factor=simple_chaos_slider.value,
                qualitative_threshold=simple_threshold_slider.value
            )

            # Run simulation
            history, transitions = system.evolve(epochs=simple_epochs_slider.value)

            # Execution time
            elapsed_time = time.time() - start_time
            print(f"‚è±Ô∏è  Execution time: {elapsed_time:.2f} seconds")

            # Visualization
            print("\nüñºÔ∏è  CREATING VISUALIZATIONS...")
            system.visualize()

            # Save results
            print("\nüíæ SAVING RESULTS...")
            np.save('simple_xenopoulos_history.npy', np.array([h['synthesis'] for h in history]))
            np.save('simple_xenopoulos_transitions.npy', np.array(transitions))

            print("‚úÖ Simulation completed successfully!")
            print("üìÅ Data saved as:")
            print("   ‚Ä¢ simple_xenopoulos_history.npy")
            print("   ‚Ä¢ simple_xenopoulos_transitions.npy")

        except Exception as e:
            print(f"‚ùå ERROR: {str(e)}")
            import traceback
            traceback.print_exc()

simple_run_button.on_click(run_simple_simulation)

# Create control panel for simplified system
simple_control_panel = widgets.VBox([
    widgets.HTML("<h3>üéõÔ∏è SIMPLIFIED XENOPOULOS SYSTEM</h3>"),
    widgets.HTML("<p style='color: #666;'>No PyTorch - Fast and stable operation</p>"),
    simple_dim_slider,
    simple_epochs_slider,
    simple_chaos_slider,
    simple_threshold_slider,
    widgets.HTML("<hr>"),
    simple_run_button,
    widgets.HTML("<hr>"),
    simple_output
])

# Display
display(simple_control_panel)

# ===================================================================
# CHAPTER 6: DEMONSTRATION AND UTILITY FUNCTIONS
# ===================================================================

def demo_inrc_operators():
    """Demonstrate INRC operators"""
    print("\n" + "="*70)
    print("INRC OPERATORS DEMONSTRATION")
    print("="*70)

    # Create group (use 3D for proper operation)
    print("‚ÑπÔ∏è  Using 3D for demonstration...")
    group = XenopoulosKlein4Group(dimension=3)

    # Test vector
    test_vector = np.array([1.0, 2.0, 3.0])
    print(f"\nüìä Test vector: {test_vector}")

    # Apply all operators
    transformations = group.get_all_transformations(test_vector)
    for op_name, result in transformations.items():
        print(f"   {op_name}(v) = {result.round(3)}")

    # Cayley table
    print(f"\nüìã Cayley Table of Klein-4 Group:")
    cayley = group.get_cayley_table()
    print("     I  N  R  C")
    print("   " + "-"*17)
    for op1 in ['I', 'N', 'R', 'C']:
        row = f"{op1} | "
        for op2 in ['I', 'N', 'R', 'C']:
            row += f"{cayley[op1][op2]}  "
        print(row)

def demo_complete_system():
    """Demonstrate complete system"""
    print("\n" + "="*70)
    print("COMPLETE SYSTEM DEMONSTRATION")
    print("="*70)

    try:
        print("‚ÑπÔ∏è  Creating 3D system...")
        system = XenopoulosFourthStructure(dimension=3)

        print("\nüöÄ Running 100 epochs demonstration...")
        history, transitions = system.evolve_system(epochs=100, verbose=True)

        print(f"\nüìä Results:")
        print(f"   ‚Ä¢ Syntheses generated: {len(history)}")
        print(f"   ‚Ä¢ Qualitative transitions: {len(transitions)}")

        if transitions:
            print(f"\n‚ö° First transition:")
            first_trans = transitions[0]
            print(f"   Epoch: {first_trans['epoch']}")
            print(f"   Synthesis norm: {first_trans['synthesis_norm']:.3f}")
            print(f"   Thesis before: {first_trans['thesis_before'].round(3)}")
            print(f"   Thesis after: {first_trans['thesis_after'].round(3)}")

    except Exception as e:
        print(f"‚ùå Error: {str(e)}")

print("\n" + "="*70)
print("ADDITIONAL FUNCTIONS")
print("="*70)
print("""
üìö You can call these functions:

1. demo_inrc_operators() - Demonstrate INRC operators (3D)
2. demo_complete_system() - Demonstrate complete system (100 epochs)

üéõÔ∏è  The main simulation runs automatically from the control panel.

‚ö†Ô∏è  IMPORTANT: The theory works best with dimensions 2 or 3.
    For higher dimensions, the R operator changes mathematical properties.

üìä Results are automatically saved as:
   ‚Ä¢ simple_xenopoulos_history.npy
   ‚Ä¢ simple_xenopoulos_transitions.npy
""")

print("\n" + "="*70)
print("USAGE INSTRUCTIONS")
print("="*70)
print("""
1. USE SIMPLIFIED SYSTEM (Recommended):
   ‚Ä¢ Set parameters in the control panel above
   ‚Ä¢ Press 'RUN SIMPLIFIED SIMULATION'
   ‚Ä¢ View results and visualizations

2. CHARACTERISTICS OF SIMPLIFIED SYSTEM:
   ‚Ä¢ 100% stable (no CUDA issues)
   ‚Ä¢ Fast execution
   ‚Ä¢ Full implementation of INRC operators
   ‚Ä¢ Qualitative transitions
   ‚Ä¢ Complete result visualization

3. RECOMMENDATIONS:
   ‚Ä¢ Use dimension 2 or 3 for classical dialectics
   ‚Ä¢ Quality threshold: 0.6-1.2 (depends on dimension)
   ‚Ä¢ Epochs: 200-500 for good statistics
   ‚Ä¢ Chaos factor: 0.01-0.1 for interesting dynamics
""")

print("\n‚úÖ THE SYSTEM IS READY FOR IMMEDIATE USE!")
print("   Press the green button to start the simulation!")
print("="*70)

# Quick test button
quick_test_button = widgets.Button(
    description='üéØ QUICK TEST (3D, 100 epochs)',
    button_style='info',
    layout=widgets.Layout(width='auto', height='40px')
)

quick_output = widgets.Output()

def run_quick_test(button):
    with quick_output:
        clear_output(wait=True)
        print("üöÄ STARTING QUICK TEST...")

        start_time = time.time()

        try:
            system = SimplifiedXenopoulosSystem(dimension=3)
            history, transitions = system.evolve(epochs=100)

            elapsed_time = time.time() - start_time

            print("‚úÖ Quick test completed!")
            print(f"   ‚Ä¢ Time: {elapsed_time:.2f} seconds")
            print(f"   ‚Ä¢ Syntheses generated: {len(history)}")
            print(f"   ‚Ä¢ Qualitative transitions: {len(transitions)}")

            # Quick visualization
            if len(history) > 0:
                fig, axes = plt.subplots(1, 2, figsize=(12, 4))

                # 1. Norm evolution
                norms = [h['norm'] for h in history]
                axes[0].plot(norms, 'b-', linewidth=2)
                axes[0].axhline(0.8, color='r', linestyle='--', alpha=0.7)
                if transitions:
                    trans_epochs = [t['epoch'] for t in transitions]
                    trans_norms = [t['norm'] for t in transitions]
                    axes[0].scatter(trans_epochs, trans_norms, color='gold', s=100, zorder=5)
                axes[0].set_title('Synthesis Evolution')
                axes[0].set_xlabel('Epoch')
                axes[0].set_ylabel('Synthesis Norm')
                axes[0].grid(True, alpha=0.3)

                # 2. 2D Phase Space
                history_array = np.array([h['synthesis'] for h in history])
                if len(history_array) > 10:
                    axes[1].scatter(history_array[:, 0], history_array[:, 1],
                                  c=range(len(history_array)), cmap='viridis', s=20)
                    axes[1].plot(history_array[:, 0], history_array[:, 1], 'k-', alpha=0.3)
                    axes[1].set_title('Phase Space (2D Projection)')
                    axes[1].set_xlabel('Component 1')
                    axes[1].set_ylabel('Component 2')
                    axes[1].grid(True, alpha=0.3)

                plt.tight_layout()
                plt.show()

        except Exception as e:
            print(f"‚ùå Error: {str(e)}")

quick_test_button.on_click(run_quick_test)

display(quick_test_button)
display(quick_output)

print("\nüéâ XENOPOULOS FOURTH LOGICAL STRUCTURE - READY TO EXPLORE!")
print("   The complete dialectical system is now running in your Colab environment.")
print("   Start with the 'QUICK TEST' or configure your own parameters!")
